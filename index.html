<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Two-Week Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Lexend', Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #121212;
      color: #e0e0e0;
    }
    .controls { margin: 0.5rem 0; }
    .controls button {
      background: #333;
      color: #e0e0e0;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 600;
      font-size: 1rem;
    }
    .controls input[type="date"] {
      background: #1e1e1e;
      color: #e0e0e0;
      border: 1px solid #333;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 300;
      font-size: 1rem;
    }
    .controls label {
      margin-right: 0.25rem;
      font-weight: 600;
    }
    .calendar {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.5rem;
    }
    .day {
      border: 1px solid #333;
      background: #1e1e1e;
      padding: 5px;
      display: flex;
      flex-direction: column;
      position: relative;
      transition: min-height 0.2s;
      min-height: 150px;
    }
    .day.inactive {
      opacity: 0.35;
    }
    .day.inactive h3 {
      color: #bdbdbd;
    }
    .day h3 {
      margin: 0 0 5px;
      font-size: 20pt;
      color: #e0e0e0;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 600;
      letter-spacing: 0.5px;
      text-align: center;
    }
    .day-add-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid #333;
      background: #2a2a2a;
      color: #e0e0e0;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 600;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .day-add-btn:hover {
      background: #3a3a3a;
    }
    .day.inactive .day-add-btn {
      display: none;
    }
    .tile {
      min-height: 5rem;
      padding: 0.5rem;
      margin: 3px 0;
      border-radius: 6px;
      position: relative;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      overflow: visible;
      word-break: break-word;
      font-size: 10pt;
      color: #000;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 300;
      background: #fff4c2;
      box-shadow: 0 2px 8px #0002;
      transition: box-shadow 0.15s, transform 0.15s;
      cursor: grab;
    }
    .tile.color-0 { background: #ffdcdc; }
    .tile.color-1 { background: #fff4c2; }
    .tile.color-2 { background: #dcffe4; }
    .tile.color-3 { background: #dceaff; }
    .tile.color-4 { background: #f0dcff; }
    .tile.color-5 { background: #ffebdc; }

    .calendar .tile { width: 100%; }
    .holding-area .tile { width: calc((100% - 3rem) / 7); }

    .tile-content {
      width: 100%;
      text-align: center;
      outline: none;
      background: transparent;
      border: none;
      font-size: 10pt;
      color: #000;
      min-height: 2.5rem;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 300;
      word-break: break-word;
      cursor: pointer;
    }
    .tile-content[contenteditable="true"] {
      background: #f9f9f9;
      color: #222;
      cursor: text;
    }
    .tile .del-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      background: none;
      border: none;
      color: #000;
      font-size: 22px;
      font-weight: bold;
      line-height: 1;
      cursor: pointer;
      z-index: 10;
      padding: 0 2px;
    }
    .tile .color-btn {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: none;
      border: none;
      font-size: 20px;
      color: #222;
      cursor: pointer;
      z-index: 10;
      padding: 0 2px;
    }
    .tile .link-btn {
      position: absolute;
      bottom: 6px;
      left: 6px;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid #0002;
      background: rgba(255,255,255,0.55);
      font-size: 18px;
      color: #222;
      cursor: pointer;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tile .link-btn:hover {
      background: rgba(255,255,255,0.8);
    }
    .tile .link-btn.has-link {
      background: rgba(255,255,255,0.85);
      border-color: #0004;
    }
    /* Step L3: inline link editor UI */
    .tile .link-editor {
      position: absolute;
      top: -44px;
      left: 6px;
      right: 6px;
      display: none;
      gap: 6px;
      align-items: center;
      padding: 6px;
      border-radius: 10px;
      background: rgba(20,20,20,0.92);
      border: 1px solid #444;
      box-shadow: 0 6px 18px #0006;
      z-index: 50;
    }
    .tile .link-editor.show { display: flex; }
    .tile .link-input {
      flex: 1;
      min-width: 0;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #444;
      background: #111;
      color: #e0e0e0;
      font-family: 'Lexend', Arial, sans-serif;
      font-weight: 300;
      font-size: 10.5pt;
      outline: none;
    }
    .tile .link-small-btn {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #444;
      background: #222;
      color: #e0e0e0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
      padding: 0;
    }
    .tile .link-small-btn:hover { background: #2d2d2d; }
    .tile .link-small-btn.danger {
      border-color: #6a2a2a;
      background: #2a1414;
    }
    .tile .link-small-btn.danger:hover { background: #3a1a1a; }
    .tile .up-btn, .tile .down-btn {
      position: absolute;
      left: 6px;
      width: 24px;
      height: 24px;
      background: none;
      border: none;
      font-size: 18px;
      color: #444;
      cursor: pointer;
      z-index: 10;
      padding: 0;
      line-height: 1;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      transition: background 0.15s;
    }
    .tile .up-btn { top: 6px; }
    .tile .down-btn { bottom: 6px; }
    .tile .up-btn:hover, .tile .down-btn:hover { background: #fff8; }
    .holding-area {
      margin-top: 2rem;
      padding: 1rem;
      background: #2a2a2a;
      min-height: 120px;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      border-radius: 8px;
    }
    a {
      color: #1266cc;
      word-break: break-all;
    }
    .tile.drag-over {
      outline: 3px dashed #0077cc;
      background: #bde3ff !important;
    }
    .tile.placeholder {
      border: 2px dashed #999;
      background: #eee !important;
      min-height: 40px;
      margin: 3px 0;
    }
    /* Extra drop target above the first tile in a day (reduces top-insert jank) */
    .top-drop {
      height: 18px;
      margin: 2px 0 4px;
      border-radius: 6px;
    }
    .top-drop.drag-over {
      outline: 3px dashed #0077cc;
      background: #bde3ff33;
    }
  </style>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
    import { getFirestore, doc, setDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAEpv0ZHT3fwo9aIsJKyzvk9EPtG70HNkk",
      authDomain: "calendartiles.firebaseapp.com",
      projectId: "calendartiles",
      storageBucket: "calendartiles.appspot.com",
      messagingSenderId: "960760935764",
      appId: "1:960760935764:web:4eef1929b9c40416d984c1",
      measurementId: "G-S39474K89Y"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const docRef = doc(db, "calendarState", "shared");

    (async () => {
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists()) {
        // Step E1: initialize shared trip settings along with tiles
        const toISO = (d) => {
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          return `${y}-${m}-${day}`;
        };
        const start = new Date();
        const end = new Date(start.getFullYear(), start.getMonth(), start.getDate());
        end.setDate(end.getDate() + 13);

        await setDoc(docRef, {
          tiles: [],
          tripStartISO: toISO(start),
          tripEndISO: toISO(end)
        });
      }
    })();

    const days = [
      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
    ];
    const pastelColors = [0, 1, 2, 3, 4, 5];

    // --- Trip date helpers (Step C)
    function formatDateLabel(iso) {
      const d = fromISODate(iso);
      // Short month label, e.g. "Jan 8"
      const month = d.toLocaleString(undefined, { month: "short" });
      return `${month} ${d.getDate()}`;
    }

    function getActiveDatesISO(startISO, endISO) {
      if (!startISO || !endISO) return [];
      const start = fromISODate(startISO);
      const end = fromISODate(endISO);
      if (end < start) return [];

      const out = [];
      const cur = new Date(start.getFullYear(), start.getMonth(), start.getDate());
      const maxDays = 366; // safety cap
      let guard = 0;

      while (cur <= end && guard < maxDays) {
        out.push(toISODate(cur));
        cur.setDate(cur.getDate() + 1);
        guard++;
      }
      return out;
    }

    function isISODateString(s) {
      return typeof s === "string" && /^\d{4}-\d{2}-\d{2}$/.test(s);
    }

    function ensureTilesInActiveRange(activeSet) {
      // Keep tiles reachable by moving out-of-range tiles back to holding.
      let changed = false;
      for (const t of tiles) {
        if (t.location && !activeSet.has(t.location)) {
          t.location = null;
          changed = true;
        }
      }
      return changed;
    }

    function normalizeTileLocationsToISO() {
      // Step D: enforce ISO-only locations. Any legacy/non-ISO location becomes holding.
      let changed = false;
      for (const t of tiles) {
        if (t.location && !isISODateString(t.location)) {
          t.location = null;
          changed = true;
        }
      }
      return changed;
    }

    let tiles = [];
    let draggingId = null;
    let dragOverId = null;
    let dragOverPos = null;
    let dragTargetDay = null;

    // Step G3.1: when a tile is newly created, open it immediately for editing
    let pendingEditTileId = null;

    // Step J2: apply drag hover visuals without re-rendering (prevents flicker / ðŸš« cursor)
    let dragHoverEl = null;
    function clearDragHover() {
      if (!dragHoverEl) return;
      dragHoverEl.classList.remove("drag-over");
      dragHoverEl.style.marginTop = "3px";
      dragHoverEl.style.marginBottom = "3px";
      dragHoverEl = null;
    }
    function applyDragHover(el, pos) {
      if (!el) return;
      el.classList.add("drag-over");
      el.style.marginTop = (pos === "above") ? "28px" : "3px";
      el.style.marginBottom = (pos === "below") ? "28px" : "3px";
      dragHoverEl = el;
    }

    function linkify(text) {
      if (!text) return "";
      return text.replace(
        /(https?:\/\/[^\s<]+)/g,
        url => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`
      ).replace(/\n/g, '<br>');
    }

    const calendarEl = document.getElementById("calendar");
    const holdingAreaEl = document.getElementById("holdingArea");

    // Trip settings (Step B: state + wiring; calendar rendering will be updated in Step C)
    let tripStartISO = null;
    let tripEndISO = null;

    function toISODate(d) {
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function fromISODate(iso) {
      // Create a local date (avoids UTC parsing quirks of new Date('YYYY-MM-DD'))
      const [y, m, d] = iso.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function addDaysISO(iso, daysToAdd) {
      const d = fromISODate(iso);
      d.setDate(d.getDate() + daysToAdd);
      return toISODate(d);
    }

    function initTripControls() {
      const startInput = document.getElementById("tripStart");
      const endInput = document.getElementById("tripEnd");
      const applyBtn = document.getElementById("applyTrip");

      if (!startInput || !endInput || !applyBtn) return;

      // Default to a 14-day window starting today (local)
      const defaultStart = toISODate(new Date());
      const defaultEnd = addDaysISO(defaultStart, 13);

      // Initialize inputs (only if empty)
      if (!startInput.value) startInput.value = defaultStart;
      if (!endInput.value) endInput.value = defaultEnd;

      // Initialize state from inputs
      tripStartISO = startInput.value;
      tripEndISO = endInput.value;

      applyBtn.addEventListener("click", () => {
        const s = startInput.value;
        const e = endInput.value;
        if (!s || !e) return;

        // Ensure start <= end
        if (fromISODate(e) < fromISODate(s)) {
          // Swap if user entered them backwards
          startInput.value = e;
          endInput.value = s;
          tripStartISO = e;
          tripEndISO = s;
        } else {
          tripStartISO = s;
          tripEndISO = e;
        }

        // Step D: enforce ISO locations and keep tiles in-range for the selected trip.
        let changed = false;
        changed = normalizeTileLocationsToISO() || changed;
        const activeDates = getActiveDatesISO(tripStartISO, tripEndISO);
        const activeSet = new Set(activeDates);
        changed = ensureTilesInActiveRange(activeSet) || changed;

        // Step E4: always persist trip settings on Apply (even if tiles didn't change)
        syncToFirestore();

        renderAll();
      });
    }

    function renderCalendar() {
      calendarEl.innerHTML = "";
      const baseTileHeight = 80;

      const activeDates = getActiveDatesISO(tripStartISO, tripEndISO);
      if (activeDates.length === 0) return;

      const firstDow = fromISODate(activeDates[0]).getDay(); // 0=Sun..6=Sat
      const totalCells = Math.ceil((firstDow + activeDates.length) / 7) * 7;

      for (let cell = 0; cell < totalCells; cell++) {
        const dateIdx = cell - firstDow;
        const isActive = dateIdx >= 0 && dateIdx < activeDates.length;

        const dayBox = document.createElement("div");
        dayBox.className = isActive ? "day" : "day inactive";

        const title = document.createElement("h3");

        if (isActive) {
          const iso = activeDates[dateIdx];
          const dowLabel = days[cell % 7];
          const dateLabel = formatDateLabel(iso);

          dayBox.dataset.date = iso;

          const dayTiles = tiles
            .filter(t => t.location === iso)
            .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
          const minHeightPx = Math.max(150, (dayTiles.length + 1.5) * baseTileHeight);
          dayBox.style.minHeight = minHeightPx + "px";

          dayBox.addEventListener("dragover", (e) => {
            e.preventDefault();
            if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
            if (!draggingId) return;

            // Step H3: only treat this as a "day" hover if we're not currently over a tile.
            // (Prevents day hover from fighting tile hover insertion cues.)
            if (e.target && e.target.closest && e.target.closest(".tile")) return;

            dragTargetDay = iso;
            dragOverId = null;
            dragOverPos = "day";
          });

          dayBox.addEventListener("drop", (e) => {
            e.preventDefault();
            if (!draggingId) return;
            moveTileToDay(draggingId, iso);
            clearDragHover();
            draggingId = null;
            dragOverId = null;
            dragOverPos = null;
            dragTargetDay = null;
            renderAll();
          });

          title.innerHTML = `${dowLabel}<br>${dateLabel}`;
          dayBox.appendChild(title);

          // Step G2: add a + button to each active day header (creates a tile in this day)
          const addBtn = document.createElement("button");
          addBtn.className = "day-add-btn";
          addBtn.type = "button";
          addBtn.title = "Add tile";
          addBtn.textContent = "+";
          addBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            const id = `tile-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
            tiles.push({
              id,
              text: "New Activity",
              color: 0,
              location: iso,
              order: Date.now(),
              link: null
            });

            pendingEditTileId = id;
            syncToFirestore();
            renderAll();
          });
          dayBox.appendChild(addBtn);

          // Drop zone above the first tile (so "insert at top" is easy)
          const topDrop = document.createElement("div");
          topDrop.className = "top-drop";
          topDrop.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
            if (!draggingId) return;
            topDrop.classList.add("drag-over");
          });
          topDrop.addEventListener("dragleave", () => {
            topDrop.classList.remove("drag-over");
          });
          topDrop.addEventListener("drop", (e) => {
            e.preventDefault();
            e.stopPropagation();
            topDrop.classList.remove("drag-over");
            if (!draggingId) return;

            const moving = tiles.find(t => t.id === draggingId);
            if (!moving) return;

            // Move into this day and place above the first tile
            tiles = tiles.filter(t => t.id !== draggingId);
            moving.location = iso;

            const firstOrder = (dayTiles[0] && dayTiles[0].order != null) ? dayTiles[0].order : Date.now();
            moving.order = firstOrder - 1;

            tiles.push(moving);
            syncToFirestore();

            clearDragHover();
            draggingId = null;
            dragOverId = null;
            dragOverPos = null;
            dragTargetDay = null;
            renderAll();
          });

          dayBox.appendChild(topDrop);

          dayTiles.forEach((tileData, idx) => {
            const tile = renderTile(tileData, dayTiles, idx);
            dayBox.appendChild(tile);
          });
        } else {
          // Inactive padding cell: show day-of-week only.
          title.innerHTML = `${days[cell % 7]}<br>&nbsp;`;
          dayBox.appendChild(title);
        }

        calendarEl.appendChild(dayBox);
      }
    }

    function renderTile(data, siblingTiles, idxInDay) {
      const tile = document.createElement("div");
      tile.className = `tile color-${data.color}`;
      tile.draggable = true;
      tile.dataset.id = data.id;

      // Drag state (required for day drop handlers to accept the drop)
      tile.ondragstart = (e) => {
        draggingId = data.id;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", data.id);
      };

      tile.ondragend = () => {
        draggingId = null;
        dragOverId = null;
        dragOverPos = null;
        dragTargetDay = null;
        clearDragHover();
        renderAll();
      };

      // Step H1: track hover target + whether we're inserting above/below a tile
      tile.ondragover = (e) => {
        if (!draggingId || draggingId === data.id) return;
        e.preventDefault();
        // Helps the browser show a valid drop target (reduces ðŸš« icon)
        if (e.dataTransfer) e.dataTransfer.dropEffect = "move";

        const rect = tile.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const pos = (e.clientY < midpoint) ? "above" : "below";

        // Track target for H2 drop logic
        dragOverId = data.id;
        dragOverPos = pos;
        dragTargetDay = data.location ?? null;

        // Apply hover visuals directly, without re-render
        if (dragHoverEl !== tile) {
          clearDragHover();
          applyDragHover(tile, pos);
        } else {
          // same tile, but maybe pos flipped
          applyDragHover(tile, pos);
        }
      };

      tile.ondragleave = (e) => {
        // Only clear when we truly leave the tile, not when moving between its children.
        // (dragleave fires a lot as you cross buttons/text inside the tile.)
        if (e && e.relatedTarget && tile.contains(e.relatedTarget)) return;

        if (dragHoverEl === tile) {
          clearDragHover();
        }
        if (dragOverId === data.id) {
          dragOverId = null;
          dragOverPos = null;
          dragTargetDay = null;
        }
      };

      // Step H2: drop onto a tile inserts above/below (Trello-style)
      tile.ondrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!draggingId || draggingId === data.id) return;

        const moving = tiles.find(t => t.id === draggingId);
        if (!moving) return;

        // Determine target "column" (day ISO or holding/null)
        const targetLoc = data.location ?? null;

        // Remove moving tile from global list first
        tiles = tiles.filter(t => t.id !== draggingId);

        // Work with siblings as rendered (already sorted), excluding the moving tile
        const siblings = siblingTiles.filter(t => t.id !== draggingId);
        const targetIdx = siblings.findIndex(t => t.id === data.id);
        if (targetIdx === -1) return;

        const pos = (dragOverPos === "above" || dragOverPos === "below") ? dragOverPos : "below";

        let prevOrder;
        let nextOrder;

        if (pos === "above") {
          nextOrder = (siblings[targetIdx].order ?? Date.now());
          prevOrder = (targetIdx > 0) ? (siblings[targetIdx - 1].order ?? (nextOrder - 1)) : (nextOrder - 1);
        } else {
          prevOrder = (siblings[targetIdx].order ?? Date.now());
          nextOrder = (targetIdx < siblings.length - 1) ? (siblings[targetIdx + 1].order ?? (prevOrder + 1)) : (prevOrder + 1);
        }

        moving.location = targetLoc;
        moving.order = (prevOrder + nextOrder) / 2;

        tiles.push(moving);
        syncToFirestore();

        clearDragHover();
        draggingId = null;
        dragOverId = null;
        dragOverPos = null;
        dragTargetDay = null;
        renderAll();
      };

      let isEditing = (pendingEditTileId === data.id);
      // Step K1: capture the tile's text when entering edit mode (for cancel/revert later)
      let editOriginalText = data.text || "";
      const content = document.createElement("div");
      content.className = "tile-content";
      content.spellcheck = true;

      function renderContent() {
        if (isEditing) {
          content.contentEditable = true;
          content.innerText = data.text;

          // Step G3.3: focus + put caret at end after the element is in the DOM
          requestAnimationFrame(() => {
            content.focus();
            const range = document.createRange();
            range.selectNodeContents(content);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          });

          // Clear the pending marker so only the newly created tile auto-opens
          if (pendingEditTileId === data.id) pendingEditTileId = null;
        } else {
          content.contentEditable = false;
          content.innerHTML = linkify(data.text || "");
        }
      }
      renderContent();

      content.addEventListener("dblclick", () => {
        // Step K1: snapshot the original text at the moment editing begins
        editOriginalText = data.text || "";
        isEditing = true;
        renderContent();
      });

      // Step K2: keyboard controls while editing
      // Enter = save & exit (Shift+Enter allows newline)
      // Esc = cancel & revert
      content.addEventListener("keydown", (e) => {
        if (!isEditing) return;

        if (e.key === "Escape") {
          e.preventDefault();
          // Revert to the original text and exit edit mode without saving
          data.text = editOriginalText;
          isEditing = false;
          renderContent();
          return;
        }

        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          // Save and exit edit mode
          data.text = content.innerText.trim();
          isEditing = false;
          syncToFirestore();
          renderContent();
        }
      });

      content.addEventListener("blur", () => {
        if (isEditing) {
          isEditing = false;
          data.text = content.innerText.trim();
          syncToFirestore();
          renderContent();
        }
      });

      const del = document.createElement("button");
      del.className = "del-btn";
      del.innerText = "Ã—";
      del.onclick = (e) => {
        e.stopPropagation();
        tiles = tiles.filter(t => t.id !== data.id);
        syncToFirestore();
      };

      const colorBtn = document.createElement("button");
      colorBtn.className = "color-btn";
      colorBtn.innerText = "ðŸŽ¨";
      colorBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const idx = tiles.findIndex(t => t.id === data.id);
        if (idx !== -1) {
          tiles[idx].color = (tiles[idx].color + 1) % pastelColors.length;
          syncToFirestore();
        }
      };

      // Step L3: inline link editor (single link per tile)
      let isLinkEditing = false;

      const linkEditor = document.createElement("div");
      linkEditor.className = "link-editor";
      linkEditor.draggable = false;

      const linkInput = document.createElement("input");
      linkInput.className = "link-input";
      linkInput.type = "text";
      linkInput.placeholder = "insert link";
      linkInput.value = data.link || "";
      linkInput.draggable = false;

      const saveLinkBtn = document.createElement("button");
      saveLinkBtn.className = "link-small-btn";
      saveLinkBtn.type = "button";
      saveLinkBtn.title = "Save link";
      saveLinkBtn.textContent = "âœ“";
      saveLinkBtn.draggable = false;

      const clearLinkBtn = document.createElement("button");
      clearLinkBtn.className = "link-small-btn danger";
      clearLinkBtn.type = "button";
      clearLinkBtn.title = "Clear link";
      clearLinkBtn.textContent = "ðŸ—‘ï¸";
      clearLinkBtn.draggable = false;

      const closeLinkBtn = document.createElement("button");
      closeLinkBtn.className = "link-small-btn";
      closeLinkBtn.type = "button";
      closeLinkBtn.title = "Close";
      closeLinkBtn.textContent = "âœ•";
      closeLinkBtn.draggable = false;

      function normalizeUrl(raw) {
        const s = (raw || "").trim();
        if (!s) return "";
        if (!/^https?:\/\//i.test(s)) return `https://${s}`;
        return s;
      }

      function openLinkEditor() {
        isLinkEditing = true;
        linkInput.value = data.link || "";
        linkEditor.classList.add("show");
        requestAnimationFrame(() => {
          linkInput.focus();
          linkInput.select();
        });
      }

      function closeLinkEditor() {
        isLinkEditing = false;
        linkEditor.classList.remove("show");
      }

      // Prevent drag-start when interacting with the editor
      linkEditor.addEventListener("mousedown", (e) => e.stopPropagation());
      linkEditor.addEventListener("click", (e) => e.stopPropagation());

      linkInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          closeLinkEditor();
        }
        if (e.key === "Enter") {
          e.preventDefault();
          saveLinkBtn.click();
        }
      });

      saveLinkBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const normalized = normalizeUrl(linkInput.value);
        if (!normalized) {
          data.link = null;
        } else {
          try {
            const u = new URL(normalized);
            data.link = u.href;
          } catch {
            alert("That doesn't look like a valid URL.");
            return;
          }
        }
        closeLinkEditor();
        syncToFirestore();
        renderAll();
      });

      clearLinkBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        data.link = null;
        closeLinkEditor();
        syncToFirestore();
        renderAll();
      });

      closeLinkBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeLinkEditor();
      });

      linkEditor.appendChild(linkInput);
      linkEditor.appendChild(saveLinkBtn);
      linkEditor.appendChild(clearLinkBtn);
      linkEditor.appendChild(closeLinkBtn);

      // Link button (open attached link; Shift+click edits)
      const linkBtn = document.createElement("button");
      linkBtn.className = "link-btn" + (data.link ? " has-link" : "");
      linkBtn.type = "button";
      linkBtn.title = data.link ? "Open link" : "Add link";
      linkBtn.innerText = "ðŸ”—";
      linkBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (e.shiftKey) {
          openLinkEditor();
          return;
        }

        if (isLinkEditing) {
          closeLinkEditor();
          return;
        }

        if (data.link) {
          window.open(data.link, "_blank", "noopener,noreferrer");
        } else {
          openLinkEditor();
        }
      };

      tile.appendChild(linkEditor);
      tile.appendChild(content);
      tile.appendChild(del);
      tile.appendChild(colorBtn);
      tile.appendChild(linkBtn);

      return tile;
    }

    // Minimal drop helper (solo-use): remove tile from array, set its location, append to end.
    function moveTileToDay(id, date) {
      const moving = tiles.find(t => t.id === id);
      if (!moving) return;
      tiles = tiles.filter(t => t.id !== id);
      moving.location = date;

      // Step F2: update ordering when moved so it lands predictably at the bottom
      moving.order = Date.now();

      tiles.push(moving);
      syncToFirestore();
    }

    async function syncToFirestore() {
      // Step E2: persist shared trip settings along with tiles (merge to avoid wiping fields)
      await setDoc(docRef, { tiles, tripStartISO, tripEndISO }, { merge: true });
    }

    onSnapshot(docRef, (docSnap) => {
      if (docSnap.exists() && Array.isArray(docSnap.data().tiles)) {
        const data = docSnap.data();
        tiles = data.tiles;

        // Step E3: load shared trip settings from Firestore and reflect them in the UI/state
        if (isISODateString(data.tripStartISO) && isISODateString(data.tripEndISO)) {
          tripStartISO = data.tripStartISO;
          tripEndISO = data.tripEndISO;

          const startInput = document.getElementById("tripStart");
          const endInput = document.getElementById("tripEnd");
          if (startInput && startInput.value !== tripStartISO) startInput.value = tripStartISO;
          if (endInput && endInput.value !== tripEndISO) endInput.value = tripEndISO;
        }

        // Step D: normalize legacy locations + keep tiles within the current trip.
        let changed = false;
        changed = normalizeTileLocationsToISO() || changed;
        if (tripStartISO && tripEndISO) {
          const activeDates = getActiveDatesISO(tripStartISO, tripEndISO);
          const activeSet = new Set(activeDates);
          changed = ensureTilesInActiveRange(activeSet) || changed;
        }
        if (changed) syncToFirestore();

        renderAll();
      }
    });

    function renderAll() {
      renderCalendar();
      renderHolding();
    }

    function renderHolding() {
      holdingAreaEl.innerHTML = '';
      const holdingTiles = tiles
        .filter(t => !t.location)
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      holdingTiles.forEach(tileData => {
        const tile = renderTile(tileData, holdingTiles, 0);
        holdingAreaEl.appendChild(tile);
      });

      // Allow dropping tiles back into holding area
      holdingAreaEl.ondragover = (e) => {
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
      };

      holdingAreaEl.ondrop = (e) => {
        e.preventDefault();
        if (!draggingId) return;
        moveTileToDay(draggingId, null);
        clearDragHover();
        draggingId = null;
        renderAll();
      };
    }

    window.createTile = function createTile() {
      const id = `tile-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
      tiles.push({ id, text: "New Activity", color: 0, location: null, order: Date.now(), link: null });
      pendingEditTileId = id;
      syncToFirestore();
      renderAll();
    };

    window.addEventListener("DOMContentLoaded", () => {
      initTripControls();
      renderAll();
    });
  </script>
</head>
<body>
  <h3>Trip Settings</h3>
  <div class="controls" id="tripControls">
    <label for="tripStart">Start</label>
    <input id="tripStart" type="date">
    <label for="tripEnd" style="margin-left: 0.75rem;">End</label>
    <input id="tripEnd" type="date">
    <button id="applyTrip" type="button" style="margin-left: 0.75rem;">Apply Trip</button>
  </div>

  <div id="calendar" class="calendar"></div>
  <h3>Holding Area</h3>
  <div class="controls">
    <button onclick="createTile()">âž• Create Tile</button>
  </div>
  <div id="holdingArea" class="holding-area"></div>
</body>
</html>
